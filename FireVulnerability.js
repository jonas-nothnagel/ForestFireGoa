
//This is the fire vulnerability mapping code-------------------------------------------------------
//This also uses the outputs from Trend fire - input resampled tif with 40 bands - import this tif file from TrendFire.js
//inputResampled - a resampled set of the input stack
//roads layer - this layer was developed separately using QGIS and python
//dem = SRTM dem clipped to the geometry can be accessed through earth engine catalog

//Sort True fire events - prepare data ---------------------------------------------------------------
var fire13_23 = fire13_19.merge(fire20_23)
var fire13_22 = fire13_23.filter(ee.Filter.stringContains('acq_date', '-2023').not());

var fire2022 = fire13_22.filter(ee.Filter.stringContains('acq_date', '2022'))
var fireMarch2023 = fire13_23.filter(ee.Filter.stringContains('acq_date', '2023'))






// Define ROI (replace with your geometry)
var roi = pa; // Add your ROI geometry


// Generate 200 random points within the region 'pa'
var randomPts = ee.FeatureCollection.randomPoints({
  region: pa, 
  points: 200,  // Generate exactly 200 points
  seed: 42,
});
/*
// Buffer firePts by 100 meters to create an exclusion zone
var fireBuffer = fire13_22.map(function(f) { 
  return f.buffer(100); 
});

// Merge buffered areas into a single geometry
//var exclusionZone = fireBuffer.union();
//Map.addLayer(exclusionZone,{},'exclude')
// Remove points that intersect with firePts buffer
var nonFirePts = randomPts.filter(ee.Filter.bounds(fireBuffer).not());
*/

var nonFirePts = randomPts.limit(90).map(function(feat){
  return feat.set('RiskNumeric',0)
}) // these points are not intersecting fire
  

// Print and visualize results
print('Final Non-Fire Points:', nonFirePts);
Map.addLayer(nonFirePts, {color: 'blue'}, 'Non-Fire Points');
print(fire13_22,'fire Points')
// Apply filtering to categorize based on Delta T

var noFire = nonFirePts

var lowRisk = fire13_22.filter(ee.Filter.rangeContains('Delta T', 0, 25)).map(function(f) { return f.set('RiskCategory', 'Low Risk').set('RiskNumeric', 1); });
print(lowRisk.size(),'low Risk')
var moderateRisk = fire13_22.filter(ee.Filter.rangeContains('Delta T', 25, 35)).map(function(f) { return f.set('RiskCategory', 'Moderate Risk').set('RiskNumeric', 2); });
moderateRisk = moderateRisk.limit(70)
print(moderateRisk.size(),'mod Risk')
var highRisk = fire13_22.filter(ee.Filter.gte('Delta T', 35)).map(function(f) { return f.set('RiskCategory', 'High Risk').set('RiskNumeric', 3); });
print(highRisk.size(),'high Risk')


// Merge all categorized feature collections - excluding lowRisk and moderate risk
var categorizedFirePoints = noFire.merge(highRisk)//.merge(lowRisk).merge(moderateRisk)

// Print result to verify
print('Categorized Fire Points', categorizedFirePoints);

// Attach inputFeat bands to sampled points
print(inputResampled)
var sample = inputResampled.sampleRegions({
  collection: categorizedFirePoints,
  properties: ['RiskNumeric'], // Ensure fire risk is retained
  scale: 30,
  geometries: true
});
print('Sample with Bands', sample);

// Export the FeatureCollection.
Export.table.toDrive({
  collection: sample,
  description: 'fireSample',
  fileFormat: 'CSV'
});





var predictors = inputResampled.bandNames()
// Add a random value field to the sample and use it to approximately split 80%
// of the features into a training set and 20% into a validation set.
sample = sample.randomColumn('random',1);
var label = 'RiskNumeric'
var trainingSample = sample.filter('random <= 0.8');
print(trainingSample,'ts')
Export.table.toDrive({
  collection: trainingSample,
  description: 'FireRisk_ts',
  fileFormat: 'CSV'
});
var validationSample = sample.filter('random > 0.8');
// Train a 10-tree random forest classifier from the training sample.



var trainedClassifier = ee.Classifier.smileRandomForest(1000,1).train({
  //var trainedClassifier = ee.Classifier.smileCart(800,1).train({
  features: trainingSample,
  classProperty: 'RiskNumeric',
  inputProperties: predictors
});
// Get information about the trained classifier.
print('Results of trained classifier', trainedClassifier.explain());

// Get a confusion matrix and overall accuracy for the training sample.
var trainAccuracy = trainedClassifier.confusionMatrix();
print('Training error matrix', trainAccuracy);
print('Training overall accuracy', trainAccuracy.accuracy());

// Get a confusion matrix and overall accuracy for the validation sample.
validationSample = validationSample.classify(trainedClassifier);
var validationAccuracy = validationSample.errorMatrix(label, 'RiskNumeric');
print('Validation error matrix', validationAccuracy);
print('Validation accuracy', validationAccuracy.accuracy());

// Classify the reflectance image from the trained classifier.
var imgClassified = inputResampled.classify(trainedClassifier);
// Export the image, specifying the CRS, transform, and region.
Export.image.toDrive({
  image: imgClassified,
  description: 'fireVulnerability',
  //crs: projection.crs,
  //crsTransform: projection.transform,
  region: pa
});

// Add the layers to the map.
var classVis = {
  min: 0,
  max: 3,
  palette: ['006400' , '#b2fb0a', 'ffbb22', 'fa0000']
};

Map.addLayer(imgClassified, classVis, 'Classified');
Map.addLayer(trainingSample, {color: 'black'}, 'Training sample', false);
Map.addLayer(validationSample, {color: 'white'}, 'Validation sample', false);


// Classify the validation sample
var classifiedValidation = validationSample.classify(trainedClassifier);
Export.table.toDrive({
  collection: classifiedValidation,
  description: 'FireValidation',
  fileFormat: 'CSV'
});
// Compute the error matrix
var validationErrorMatrix = classifiedValidation.errorMatrix('RiskNumeric', 'classification');
print('Validation error matrix', validationErrorMatrix);

// Compute overall accuracy
var testAccuracy = validationErrorMatrix.accuracy();
print('Test Accuracy:', testAccuracy);

// Compute kappa statistic (optional)
var kappaStatistic = validationErrorMatrix.kappa();
print('Kappa Statistic:', kappaStatistic);



Map.addLayer(fireMarch2023,{color:'blue'},'2023 fire')
Map.addLayer(fire13_22,{color:'brown'},'allFirePts')

// Classify the validation sample
var classifiedValidation = validationSample.classify(trainedClassifier);
Export.table.toDrive({
  collection: fire13_22,
  description: 'tsFire',
  fileFormat: 'CSV'
});







