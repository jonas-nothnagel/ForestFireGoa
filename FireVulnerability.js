
//This is the fire vulnerability mapping code-------------------------------------------------------
//This also uses the outputs from Trend fire - 14 layers
//Additionally it also uses few inputs exported as assets from this code - NICFI, MODIS lstDay, lstNyt,
//inputResampled - a resampled set of the input stack
//roads layer - this layer was developed separately using QGIS and python

road = road.clip(pa)

//Sort True fire events - prepare data ---------------------------------------------------------------
var fire13_23 = fire13_19.merge(fire20_23)

var fire13_22 = fire13_23.filter(ee.Filter.stringContains('acq_date', '-2023').not());

print(fire13_22)
var fire2022 = fire13_22.filter(ee.Filter.stringContains('acq_date', '2022'))
var fireMarch2023 = fire13_23.filter(ee.Filter.stringContains('acq_date', '2023'))
print(fireMarch2023.size())



// This collection is not publicly accessible. To sign up for access,
// please see https://developers.planet.com/docs/integrations/gee/nicfi
//Trend calculation for NICFI --------------------------------------------------------------------
var nicfi = ee.ImageCollection('projects/planet-nicfi/assets/basemaps/asia')
            .map(function(image){
            return image.clip(pa)
});

// Filter basemaps by date and get the first image from filtered results
var basemap= nicfi.filter(ee.Filter.date('2016-03-01','2024-02-28'))
              .map(function(image){
                var n = image.normalizedDifference(['N','R']).rename('NDVI')
                return image.addBands(n)
              })


var vis = {'bands':['R','G','B'],'min':64,'max':5454,'gamma':1.8};

//Map.addLayer(basemap, vis, '2021-03 mosaic');
//Map.addLayer(basemap.normalizedDifference(['N','R']).rename('NDVI'),{min:-0.55,max:0.8,palette: 
//['8bc4f9', 'c9995c', 'c7d270','8add60','097210'
//    ]}, 'NDVI', false);
    
    
    

// Add a 'time' band to the collection for trend calculation
var planetTime = basemap.map(function(image) {
  var year = ee.Date(image.get('system:time_start')).difference(ee.Date('2016-01-01'),'year');
  return image.addBands(ee.Image.constant(year).rename('time').float());
});

var indices = ['R','G','B','N','NDVI'];


// Function to calculate trends for a single index
var calculateTrend = function(index) {
  // Select the index and time bands
  var stacked = planetTime.select(['time', index]);
  // Perform linear regression
  var regression = stacked.reduce(ee.Reducer.linearFit());
  // Extract slope and intercept
  var slope = regression.select('scale').rename(index + '_Slope'); // Trend slope
  var intercept = regression.select('offset').rename(index + '_Intercept'); // Baseline
  return slope.addBands(intercept);
};

// Calculate trends for all indices and combine results
var planetResults = indices.map(calculateTrend);
print(planetResults,'trends')
planetResults = ee.List(planetResults)
var red = planetResults.get(0)
var green = planetResults.get(1)
var blue= planetResults.get(2)
var nir = planetResults.get(3)
var NDVI = planetResults.get(4)




//Trend Calculation for MODIS LST ------------------------------------------------------------------
// Load MODIS Daily LST (MOD11A1 - Terra)
var modis = ee.ImageCollection('MODIS/061/MOD11A1')
                  .filter(ee.Filter.date('2013-01-01', '2023-02-28'))
                  .filterBounds(pa)
                  .select(['LST_Day_1km', 'LST_Night_1km', 'QC_Day']);

// Function to apply cloud masking based on QC_Day band
var cloudMaskLST = function(image) {
  var qc = image.select('QC_Day');  // Quality control band
  var mask = qc.bitwiseAnd(1).eq(0); // Keep only pixels with best quality
  
  var lstDay = image.select('LST_Day_1km').updateMask(mask).multiply(0.02).subtract(273.15).rename('LST_Day');
  var lstNight = image.select('LST_Night_1km').updateMask(mask).multiply(0.02).subtract(273.15).rename('LST_Night');
  
  return image.addBands(lstDay).addBands(lstNight).select(['LST_Day', 'LST_Night']).clip(pa);
};

// Apply cloud masking and unit conversion
var modisMasked = modis.map(cloudMaskLST);
print(modisMasked, 'Cloud Masked MODIS LST Collection');

// Add a 'time' band for trend analysis
var modisTime = modisMasked.map(function(image) {
  var year = ee.Date(image.get('system:time_start')).difference(ee.Date('2013-01-01'), 'year');
  return image.addBands(ee.Image.constant(year).rename('time').float());
});

// Function to compute trend
var lstTrend = function(index) {
  var stacked = modisTime.select(['time', index]); // Select LST and time bands
  var regression = stacked.reduce(ee.Reducer.linearFit()); // Perform linear regression
  var slope = regression.select('scale').rename(index + '_Slope'); // Trend slope
  var intercept = regression.select('offset').rename(index + '_Intercept'); // Baseline
  return slope.addBands(intercept);
};

// Compute trends for LST_Day and LST_Night
var lstDayTrend = lstTrend('LST_Day');
var lstNightTrend = lstTrend('LST_Night');

// Export the result
Export.image.toAsset({
  image: lstDayTrend,
  description: 'LSTDayMODIS_Trend2013_2023',
  assetId:'users/sravanthi_mopati/Trend2023_LSTDay_MODIS',
  region: pa,
  scale: 30,
  crs: 'EPSG:4326',
  maxPixels: 1e13
});
// Export the result
Export.image.toAsset({
  image: lstNightTrend,
  description: 'LSTNightMODIS_Trend2013_2023',
  assetId:'users/sravanthi_mopati/Trend2023_LSTNight_MODIS',
  region: pa,
  scale: 30,
  crs: 'EPSG:4326',
  maxPixels: 1e13
});
// Visualization parameters
var lstVis = { min: -2, max: 2, palette: ['blue', 'white', 'red'] };

// Display results
Map.centerObject(pa, 6);
//Map.addLayer(lstDay.select('LST_Day_Slope'), lstVis, 'LST Daytime Trend');
//Map.addLayer(lstNyt.select('LST_Night_Slope'), lstVis, 'LST Nighttime Trend');


var visualization = {
  bands: ['population'],
  min: 0.0,
  max: 50.0,
  palette: ['24126c', '1fff4f', 'd4ff50']
};

//Map.addLayer(pop, visualization, 'Population');

// Load MODIS Daily LST (MOD11A1 - Terra)
pop = pop.filter(ee.Filter.date('2013-01-01', '2021-01-01')).filterBounds(pa)
                  .select(['population']).map(function(image){
                    return image.clip(pa)
                  });

/*
//This layer is not included in this model -----------------------------------------------------------
// Add a 'time' band for trend analysis - not included in the model ----------------------------------
var popTime = pop.filterBounds(pa).map(function(image) {
  var year = ee.Date(image.get('system:time_start')).difference(ee.Date('2013-01-01'), 'year');
  return image.addBands(ee.Image.constant(year).rename('time').float());
});

// Function to compute trend
var popTrend = function(index) {
  var stacked = popTime.select(['time', index]); // Select LST and time bands
  var regression = stacked.reduce(ee.Reducer.linearFit()); // Perform linear regression
  var slope = regression.select('scale').rename(index + '_Slope'); // Trend slope
  var intercept = regression.select('offset').rename(index + '_Intercept'); // Baseline
  return slope.addBands(intercept);
};

popTrend = popTrend('population')
print(popTrend,'popTrend')
*/













Map.centerObject(pa,9)

dem = dem.clip(pa)
//Map.addLayer(dem)
//var slope = ee.Terrain.slope(dem)
// List of images

var images = [
    rain, rh,stb10, evi,  msavi, mirbi, bsi,sm,ndmi,//roadsIDW,popTrend,
  nbr, nbr2,  dem.select('slope'),smi, red,green,blue,nir,NDVI,lstDay,lstNyt,
  road,//waterBuilt15_22,//canopy_ht,roads,ndvi - i have removed landsat ndvi, alosdem.select('b1'), ee.Terrain.slope(alosdem.select('b1'))
];

// Start with the first image
var inputFeat = ee.Image(images[0]);

// Add each subsequent image as bands
for (var i = 1; i < images.length; i++) {
  inputFeat = inputFeat.addBands(ee.Image(images[i]));
}


//Resampling all the layers to 30m 
var proj = inputFeat.select('evi_Slope').projection()
var inputFeatProj = inputFeat.setDefaultProjection(proj)
// Choose the grid size and projection
var gridScale = 30;
var gridProjection = ee.Projection('EPSG:3857')
  .atScale(gridScale);
// Aggregate pixels with 'mean' statistics
var inputResamp = inputFeatProj
  .reduceResolution({
    reducer: ee.Reducer.mean(),
    maxPixels: 1024
  })
  .reproject({
    crs: gridProjection
});



Export.image.toAsset({
  image: inputResamp.clip(pa),
  description: 'inputResampled',
  assetId: 'users/sravanthi_mopati/' + 'inputResampled',
  region: pa,
  scale: 30,
  maxPixels: 1e10
});


print(inputFeat,'input features')
//Map.addLayer(inputFeat)



// Define ROI (replace with your geometry)
var roi = pa; // Add your ROI geometry


// Generate 200 random points within the region 'pa'
var randomPts = ee.FeatureCollection.randomPoints({
  region: pa, 
  points: 200,  // Generate exactly 200 points
  seed: 42,
});
/*
// Buffer firePts by 100 meters to create an exclusion zone
var fireBuffer = fire13_22.map(function(f) { 
  return f.buffer(100); 
});

// Merge buffered areas into a single geometry
//var exclusionZone = fireBuffer.union();
//Map.addLayer(exclusionZone,{},'exclude')
// Remove points that intersect with firePts buffer
var nonFirePts = randomPts.filter(ee.Filter.bounds(fireBuffer).not());
*/

var nonFirePts = randomPts.limit(90).map(function(feat){
  return feat.set('RiskNumeric',0)
}) // these points are not intersecting fire
  

// Print and visualize results
print('Final Non-Fire Points:', nonFirePts);
Map.addLayer(nonFirePts, {color: 'blue'}, 'Non-Fire Points');
print(fire13_22,'fire Points')
// Apply filtering to categorize based on Delta T

var noFire = nonFirePts

var lowRisk = fire13_22.filter(ee.Filter.rangeContains('Delta T', 0, 25)).map(function(f) { return f.set('RiskCategory', 'Low Risk').set('RiskNumeric', 1); });
print(lowRisk.size(),'low Risk')
var moderateRisk = fire13_22.filter(ee.Filter.rangeContains('Delta T', 25, 35)).map(function(f) { return f.set('RiskCategory', 'Moderate Risk').set('RiskNumeric', 2); });
moderateRisk = moderateRisk.limit(70)
print(moderateRisk.size(),'mod Risk')
var highRisk = fire13_22.filter(ee.Filter.gte('Delta T', 35)).map(function(f) { return f.set('RiskCategory', 'High Risk').set('RiskNumeric', 3); });
print(highRisk.size(),'high Risk')


// Merge all categorized feature collections - excluding lowRisk and moderate risk
var categorizedFirePoints = noFire.merge(highRisk)//.merge(lowRisk).merge(moderateRisk)

// Print result to verify
print('Categorized Fire Points', categorizedFirePoints);

// Attach inputFeat bands to sampled points
print(inputResampled)
var sample = inputResampled.sampleRegions({
  collection: categorizedFirePoints,
  properties: ['RiskNumeric'], // Ensure fire risk is retained
  scale: 30,
  geometries: true
});
print('Sample with Bands', sample);

// Export the FeatureCollection.
Export.table.toDrive({
  collection: sample,
  description: 'fireSample',
  fileFormat: 'CSV'
});





var predictors = inputResampled.bandNames()
// Add a random value field to the sample and use it to approximately split 80%
// of the features into a training set and 20% into a validation set.
sample = sample.randomColumn('random',1);
var label = 'RiskNumeric'
var trainingSample = sample.filter('random <= 0.8');
print(trainingSample,'ts')
Export.table.toDrive({
  collection: trainingSample,
  description: 'FireRisk_ts',
  fileFormat: 'CSV'
});
var validationSample = sample.filter('random > 0.8');
// Train a 10-tree random forest classifier from the training sample.



var trainedClassifier = ee.Classifier.smileRandomForest(1000,1).train({
  //var trainedClassifier = ee.Classifier.smileCart(800,1).train({
  features: trainingSample,
  classProperty: 'RiskNumeric',
  inputProperties: predictors
});
// Get information about the trained classifier.
print('Results of trained classifier', trainedClassifier.explain());

// Get a confusion matrix and overall accuracy for the training sample.
var trainAccuracy = trainedClassifier.confusionMatrix();
print('Training error matrix', trainAccuracy);
print('Training overall accuracy', trainAccuracy.accuracy());

// Get a confusion matrix and overall accuracy for the validation sample.
validationSample = validationSample.classify(trainedClassifier);
var validationAccuracy = validationSample.errorMatrix(label, 'RiskNumeric');
print('Validation error matrix', validationAccuracy);
print('Validation accuracy', validationAccuracy.accuracy());

// Classify the reflectance image from the trained classifier.
var imgClassified = inputResampled.classify(trainedClassifier);
// Export the image, specifying the CRS, transform, and region.
Export.image.toDrive({
  image: imgClassified,
  description: 'fireVulnerability',
  //crs: projection.crs,
  //crsTransform: projection.transform,
  region: pa
});

// Add the layers to the map.
var classVis = {
  min: 0,
  max: 3,
  palette: ['006400' , '#b2fb0a', 'ffbb22', 'fa0000']
};

Map.addLayer(imgClassified, classVis, 'Classified');
Map.addLayer(trainingSample, {color: 'black'}, 'Training sample', false);
Map.addLayer(validationSample, {color: 'white'}, 'Validation sample', false);


// Classify the validation sample
var classifiedValidation = validationSample.classify(trainedClassifier);
Export.table.toDrive({
  collection: classifiedValidation,
  description: 'FireValidation',
  fileFormat: 'CSV'
});
// Compute the error matrix
var validationErrorMatrix = classifiedValidation.errorMatrix('RiskNumeric', 'classification');
print('Validation error matrix', validationErrorMatrix);

// Compute overall accuracy
var testAccuracy = validationErrorMatrix.accuracy();
print('Test Accuracy:', testAccuracy);

// Compute kappa statistic (optional)
var kappaStatistic = validationErrorMatrix.kappa();
print('Kappa Statistic:', kappaStatistic);



Map.addLayer(fireMarch2023,{color:'blue'},'2023 fire')
Map.addLayer(fire13_22,{color:'brown'},'allFirePts')

// Classify the validation sample
var classifiedValidation = validationSample.classify(trainedClassifier);
Export.table.toDrive({
  collection: fire13_22,
  description: 'tsFire',
  fileFormat: 'CSV'
});







